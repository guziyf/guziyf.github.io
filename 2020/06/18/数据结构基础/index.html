<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="考研期间，通过各种途径学习数据结构的知识整理">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构基础">
<meta property="og:url" content="http://yoursite.com/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="古子の博客">
<meta property="og:description" content="考研期间，通过各种途径学习数据结构的知识整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.guziyf.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%A0%86%E6%A0%88%E5%9B%BE%E8%A7%A3">
<meta property="article:published_time" content="2020-06-18T09:28:55.000Z">
<meta property="article:modified_time" content="2020-07-14T00:24:03.853Z">
<meta property="article:author" content="Wang QiAn">
<meta property="article:tag" content="guziyf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.guziyf.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%A0%86%E6%A0%88%E5%9B%BE%E8%A7%A3">

<link rel="canonical" href="http://yoursite.com/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构基础 | 古子の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">古子の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Enjoy Coding</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-weblearn">

    <a href="/categories/weblearn" rel="section"><i class="fab fa-html5 fa-fw"></i>大前端</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://image.guziyf.com/avatar">
      <meta itemprop="name" content="Wang QiAn">
      <meta itemprop="description" content="正视无知，消除傲慢">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="古子の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 17:28:55" itemprop="dateCreated datePublished" datetime="2020-06-18T17:28:55+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-14 08:24:03" itemprop="dateModified" datetime="2020-07-14T08:24:03+08:00">2020-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>考研期间，通过各种途径学习数据结构的知识整理</p>
</blockquote>
<a id="more"></a>
<h1 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h1><h2 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h2><ul>
<li><p>目前还没有官方统一定义</p>
</li>
<li><p><strong>中文维基百科</strong>上的定义：数据结构是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的<strong>算法</strong></p>
</li>
<li><p><strong>《数据结构与算法分析》</strong>书中；数据结构是ADT（Abstrat Data Type抽象数据类型）的物理实现</p>
</li>
<li><p><strong>《数据结构、算法与应用》</strong>书中：数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。</p>
</li>
<li><p>解决问题方法的效率，跟数据的组织方式有关</p>
</li>
<li><p>clock()：捕捉从程序开始运行到clock()被调用时所耗费的时间。</p>
<script type="math/tex; mode=display">
f(x)=1+x+\frac{x^2}{2}+...+\frac{x^i}{i}+...+\frac{x^{100}}{100}</script></li>
</ul>
<p>  用不同方法计算：$f(1.1)$</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN    100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK    1e5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLK_TCK = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start, <span class="built_in">stop</span>;</span><br><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p += a[i] * <span class="built_in">pow</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p = a[i<span class="number">-1</span>] + x*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> (*f)(<span class="keyword">double</span>[], <span class="keyword">int</span>, <span class="keyword">double</span>), <span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXK; i++) &#123;</span><br><span class="line">        res = f(a, n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stop</span> = clock();</span><br><span class="line">    duration = <span class="number">1.0</span> * (<span class="built_in">stop</span> - start) / CLK_TCK / MAXK;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"f(%d) = %f\n"</span>, MAXN, res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ticks = %f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">stop</span> - start));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"多项式求和耗时%5.2e\n"</span>, duration);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[MAXN+<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        a[i] = <span class="number">1.0</span> / i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"普通方法: "</span>);</span><br><span class="line">    test(&amp;f1, a, MAXN, <span class="number">1.1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"秦九韶方法: "</span>);</span><br><span class="line">    test(&amp;f2, a, MAXN, <span class="number">1.1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通方法: f(100) = 1722.444814</span></span><br><span class="line"><span class="comment">//ticks = 223210.000000</span></span><br><span class="line"><span class="comment">//多项式求和耗时2.23e-02   耗时多</span></span><br><span class="line"><span class="comment">//秦九韶方法: f(100) = 1722.444814</span></span><br><span class="line"><span class="comment">//ticks = 36523.000000</span></span><br><span class="line"><span class="comment">//多项式求和耗时3.65e-03		耗时少</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抽象数据类型<ul>
<li>数据类型：数据对象集、数据集合相关联的操作集</li>
<li>抽象：描述数据类型的方法不依赖于具体实现</li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是算法"><a href="#1-2-什么是算法" class="headerlink" title="1.2 什么是算法"></a>1.2 什么是算法</h2><ul>
<li><p>Algorithm定义</p>
<ul>
<li>一个有限指令集</li>
<li>接受一些输入（有些情况不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
<li>每一条指令必须<ul>
<li>有充分明确的目标，不可以有歧义</li>
<li>计算机能处理的范围之内</li>
<li>描述手段要抽象</li>
</ul>
</li>
</ul>
</li>
<li><p>空间复杂度S(n)：占用存储单元的长度</p>
</li>
<li><p>时间复杂度T(n)：耗费时间的长度</p>
</li>
<li><p>二分查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> s[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)				<span class="comment">//判断是否往左或者往右的循环结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = (left+right)/<span class="number">2</span>; <span class="comment">//取中间的M</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;a)	<span class="comment">//如果i比a大，向左</span></span><br><span class="line">            right = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;a) <span class="comment">//反之，向右</span></span><br><span class="line">            left = i+<span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;	<span class="comment">//要查的数</span></span><br><span class="line">    <span class="keyword">int</span> n;	<span class="comment">//数的个数（最大值）</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> s[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">find</span>(a,s,n);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有在s中找到b"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到了b的下标为：%d\n"</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 第几次查询 | 剩余待查数 |<br>| ————— | ————— |<br>| 1          | n/2        |<br>| 2          | n/(2^2)    |<br>| 3          | n/(2^3)    |<br>| k          | n/(2^k)    |</p>
<p>经过n/(2^k)次查找后，应该找到那最后一个，所以</p>
<script type="math/tex; mode=display">
\frac{n}{2^k} ≥ 1</script><p>最坏的情况就是=1的时候，也就是K次，即：</p>
<script type="math/tex; mode=display">
k =\log_2^n</script><p>所以最坏情况下的时间复杂度为：$O(\log n)$；最好情况下为：$O(1)$</p>
<p>空间复杂度为$T(1)$因为空间占用是常数级别的</p>
</li>
</ul>
<h2 id="1-3-应用实例：最大子列和问题"><a href="#1-3-应用实例：最大子列和问题" class="headerlink" title="1.3 应用实例：最大子列和问题"></a>1.3 应用实例：最大子列和问题</h2><ul>
<li><p>分而治之（通过容易想到的$N^3$、$N^2$，再向N·logN推导得到）</p>
<ul>
<li>放在一个数组里，先一分为二，递归的找出左边最大子列和，再递归的找出右边的最大子列和，然后再求跨越边界的最大子列和</li>
<li>比如[4,-3,5,-2 | -1,2,6,-2]，先看左边遍分[4,-3 | 5,-2]，然后再分[4|-3]，找出左半边的4，再找出右半边的5，然后从[4,-3｜5,-2]，先从中间往左边扫描，得到-3，得到1，<strong>最大和左边是1</strong>，往右边得到5，得到3，<strong>最大和右边是5</strong>，所以跨越边界的最大子列和是6</li>
<li>所以时间复杂度推导如下：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
  \begin{split}
  T(N) &= 2T(\frac{N}{2})+C·O(N)\\
  &= 2(2T(\frac{N}{2^2})+C·O(\frac{N}{2}))+C·O(N)\\
  &= 4T(\frac{N}{2^2})+2C·O(N)\\
  &= 2^kT(\frac{N}{2^k})+KC·O(N)\\
  if & : 2^k = N,k = log_2^n\\
  &= N·T(1) + log_2^n·N\\
  &= O(N·logN)
  \end{split}</script><ul>
<li><p>在线处理算法（比分而治之更快，复杂度是O(N)）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSub</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += A[i];				<span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span> (ThisSum &gt; MaxSum)		</span><br><span class="line">        &#123;</span><br><span class="line">            MaxSum = ThisSum;		<span class="comment">//发现更大和则更新结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)		<span class="comment">//如果子列和为负</span></span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;				<span class="comment">//则不可能使后面的部分和增大，抛弃</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">-5</span>,<span class="number">-9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxSub(a,<span class="number">10</span>)); <span class="comment">//11 //4+5-3-5+7+3=11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从头开始，向右累加，每累加为正数且大于MaxSum则放入MaxSum</li>
<li>一个算法太快是有副作用的，即其他人读起来不好理解</li>
<li>“在线”的意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能给出正确的当前解</li>
</ul>
</li>
</ul>
<h4 id="01-复杂度1-最大子列和问题-20分"><a href="#01-复杂度1-最大子列和问题-20分" class="headerlink" title="01-复杂度1 最大子列和问题(20分)"></a>01-复杂度1 最大子列和问题(20分)</h4><p>给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }，“连续子列”被定义为{ <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<ul>
<li>数据1：与样例等价，测试基本正确性；</li>
<li>数据2：102个随机整数；</li>
<li>数据3：103个随机整数；</li>
<li>数据4：104个随机整数；</li>
<li>数据5：105个随机整数；</li>
</ul>
<p><strong>输入格式:</strong></p>
<p>输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p>
<p>输出格式:</p>
<p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure>
<p><strong>输出样例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<h4 id="思路：使用在线处理算法"><a href="#思路：使用在线处理算法" class="headerlink" title="思路：使用在线处理算法"></a>思路：使用在线处理算法</h4><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSub</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += A[i];</span><br><span class="line">        <span class="keyword">if</span> (ThisSum &gt; MaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MaxSub(a,n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="01-复杂度2-Maximum-Subsequence-Sum-25分"><a href="#01-复杂度2-Maximum-Subsequence-Sum-25分" class="headerlink" title="01-复杂度2 Maximum Subsequence Sum(25分)"></a>01-复杂度2 Maximum Subsequence Sum(25分)</h4><p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>
<p><strong>Output Specification:</strong></p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>输出有三种情况<ul>
<li>第一种是有整数的情况，即正常情况</li>
<li>第二种是全为负数，输出第一个和最后一个数</li>
<li>第三种是负数和0，输出三个0</li>
<li>第一种情况好做，第二种情况和第三种情况要区分开需要再存一个flog</li>
</ul>
</li>
</ul>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    <span class="keyword">int</span> first,last;</span><br><span class="line">    <span class="keyword">int</span> lsfirst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> zero = <span class="number">1</span>;</span><br><span class="line">    first = last = <span class="number">0</span>;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (ThisSum &gt; MaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">            last = i;</span><br><span class="line">            first = lsfirst;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;</span><br><span class="line">            lsfirst = i+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum == <span class="number">0</span>)&#123;</span><br><span class="line">            zero = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(MaxSum == <span class="number">0</span> &amp;&amp; zero == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0 0"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(MaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>,MaxSum,a[first],a[last]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d"</span>,a[<span class="number">0</span>],a[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="01-复杂度3-二分查找-20分"><a href="#01-复杂度3-二分查找-20分" class="headerlink" title="01-复杂度3 二分查找(20分)"></a>01-复杂度3 二分查找(20分)</h4><p>本题要求实现二分查找算法。</p>
<p><strong>函数接口定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>List</code>结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p>
<p><strong>裁判测试程序样例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NotFound 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">ReadInput</span><span class="params">()</span></span>; <span class="comment">/* 裁判实现，细节不表。元素从下标1开始存储 */</span></span><br><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L = ReadInput();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">    P = BinarySearch( L, X );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, P);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>
<p><strong>输入样例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12 31 55 89 101</span><br><span class="line">31</span><br></pre></td></tr></table></figure>
<p><strong>输出样例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>输入样例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">26 78 233</span><br><span class="line">31</span><br></pre></td></tr></table></figure>
<p><strong>输出样例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>首先使用的是二分法<ul>
<li>二分法的思路是：每次将有序线性表一分为二，如果所找值大于中值，就向右找，小于中值，就向左找</li>
<li>每次更新查找范围时，向左就把右节点-1，向右就把左节点+1</li>
</ul>
</li>
</ul>
<h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><ul>
<li>忽略了要查的线性表的类型</li>
<li>没有注意输入得是函数传入的表名，而使用了定义时的表名</li>
</ul>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = L-&gt;Last;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)				</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType i = (left+right)/<span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span>(L-&gt;Data[i] == X)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L-&gt;Data[i]&gt;X)&#123;</span><br><span class="line">            right = i<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h1><h2 id="2-1-线性表及其实现"><a href="#2-1-线性表及其实现" class="headerlink" title="2.1 线性表及其实现"></a>2.1 线性表及其实现</h2><ul>
<li><p>线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position p = L; <span class="comment">/* p指向L的第1个结点 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下列语句可以用 return p; 替换 */</span></span><br><span class="line">    <span class="keyword">if</span> ( p )</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 带头结点的插入 */</span></span><br><span class="line"><span class="comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 这里默认L有头结点 */</span></span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 查找P的前一个结点 */</span>        </span><br><span class="line">    <span class="keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    <span class="keyword">if</span> ( pre==<span class="literal">NULL</span> ) &#123; <span class="comment">/* P所指的结点不在L中 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置参数错误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 找到了P的前一个结点pre */</span></span><br><span class="line">        <span class="comment">/* 在P前插入新结点 */</span></span><br><span class="line">        tmp = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)); <span class="comment">/* 申请、填装结点 */</span></span><br><span class="line">        tmp-&gt;Data = X; </span><br><span class="line">        tmp-&gt;Next = P;</span><br><span class="line">        pre-&gt;Next = tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 带头结点的删除 */</span></span><br><span class="line"><span class="comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 这里默认L有头结点 */</span></span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 查找P的前一个结点 */</span>        </span><br><span class="line">    <span class="keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    <span class="keyword">if</span> ( pre==<span class="literal">NULL</span> || P==<span class="literal">NULL</span>) &#123; <span class="comment">/* P所指的结点不在L中 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除位置参数错误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 找到了P的前一个结点pre */</span></span><br><span class="line">        <span class="comment">/* 将P位置的结点删除 */</span></span><br><span class="line">        pre-&gt;Next = P-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><ol>
<li><p><em>对于线性表，在顺序存储结构和链式存储结构中查找第k个元素，其时间复杂性分别是多少？</em></p>
<ul>
<li><strong>顺序存储结构直接取到第k个，所以为O(1)</strong></li>
<li><strong>链式存储结构需要遍历，所以为O(k)</strong></li>
</ul>
</li>
<li><p><em>在顺序结构表示的线性表中，删除第i个元素（数组下标为i-1)，需要把后面的所有元素都往前挪一位，相应的语句是：</em></p>
<p><em>for (<strong><strong>___</strong></strong> )</em></p>
<pre><code>  *PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j];* 
</code></pre><p><strong>其中空缺部分的内容应该是 j = i; j&lt; = PtrL-&gt;Last; j++//使j=i时，从j-1开始每位等于它的后一位</strong></p>
</li>
</ol>
<h2 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h2><ul>
<li><p>一种线性结构，也是一种特殊的线性表</p>
</li>
<li><p>后缀表达式</p>
<ul>
<li><p>中缀表达式：a+b*c-d/e</p>
</li>
<li><p>后缀：a b c * + d e / -</p>
<ul>
<li>比如a=4 b=2 c=2 d=3 e=1</li>
<li>4 2 2<em> 然后让2</em>2 = 4</li>
<li>4 4 + 然后让4+4 = 8</li>
<li>8 3 1 / 然后让3/1 = 3</li>
<li>8 3 - 然后让8-3 = 5</li>
<li>通过验算：4+2*2-3/1=5</li>
<li>如图：后放入的先拿出来做被减数、被乘数、被除数</li>
</ul>
<p><img src="http://image.guziyf.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%A0%86%E6%A0%88%E5%9B%BE%E8%A7%A3" alt=""></p>
</li>
<li><p>前缀：- +a *bc /de</p>
</li>
</ul>
</li>
<li><p>需要有种存储方式，能顺序存储算数，并在需要时“倒序”输出</p>
</li>
<li><p><strong>先放进去的后拿出来，后放进去的先拿出来</strong></p>
</li>
<li><p><strong>堆栈(Stack)</strong>：具有一定操作约束的线性表</p>
<ul>
<li><p>只在一端（栈顶，Top）做插入、删除</p>
</li>
<li><p>插入数据：入栈(Push)</p>
</li>
<li><p>删除数据：出栈(Pop)</p>
</li>
<li><p>后入先出：Last In First Out(LIFO)</p>
</li>
<li><p>例子：放在桌子上的一堆碗</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>;<span class="comment">//生成空堆栈，最大长度为MaxSize</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Stack S, <span class="keyword">int</span> MaxSize)</span></span>;<span class="comment">//判断堆栈S是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S,ElementType item)</span></span>;<span class="comment">//将元素item压入堆栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>;<span class="comment">//判断堆栈S是否为空</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>;<span class="comment">//删除并返回栈顶元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如：Push(S,C),Push(S,B),Push(S,A),Pop(S),Pop(S),Pop(S)</p>
<ul>
<li>输出是ABC</li>
</ul>
</li>
<li><p>如：Push(S,A),Pop(S),Push(S,B),Push(S,C),Pop(S),Pop(S)</p>
<ul>
<li>输出是ACB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4><ol>
<li><p><em>借助堆栈将中缀表达式A-(B-C/D)</em>E转换为后缀表达式，则该堆栈的大小至少为<em>：<em>*4，为ABCD</em></em></p>
</li>
<li><p><em>设1、2、…、n–1、n共n个数按顺序入栈，若第一个出栈的元素是n，则第三个出栈的元素是</em>： <strong>n-2</strong></p>
</li>
<li><p><em>若用单向链表实现一个堆栈，当前链表状态为：1-&gt;2-&gt;3。当对该堆栈执行pop()、push(4)操作后，链表状态变成怎样？</em></p>
<pre><code> （1）4-&gt;2-&gt;3  (2) 1-&gt;2-&gt;4
</code></pre><p><strong>只能是（1）</strong></p>
</li>
<li><p><em>如果一堆栈的输入序列是aAbBc，输出为 abcBA，那么该堆栈所进行的操作序列是什么？ 设P代表入栈，O代表出</em>栈<strong>POPPOPPOOO</strong></p>
</li>
</ol>
<h2 id="2-3-队列及实现"><a href="#2-3-队列及实现" class="headerlink" title="2.3 队列及实现"></a>2.3 队列及实现</h2><ul>
<li><p>也是一种受限制的线性表</p>
<ul>
<li>先来先服务，也叫先进先出表</li>
</ul>
</li>
<li><p><strong>队列(Queue)</strong></p>
<ul>
<li>长度为MaxSize的队列Q = Queue，队列元素item 属于 ElementType</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Queue <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>;<span class="comment">//生成长度为MaxSize的空队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFullQ</span><span class="params">(Queue S, <span class="keyword">int</span> MaxSize)</span></span>;<span class="comment">//判断队列Q是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue S,ElementType item)</span></span>;<span class="comment">//将元素item插入队列Q中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmptyQ</span><span class="params">(Queue S)</span></span>;<span class="comment">//判断队列Q是否为空</span></span><br><span class="line"><span class="function">ElementType <span class="title">DelectQ</span><span class="params">(Queue S)</span></span>;<span class="comment">//将对头数据元素从队列中删除并返回</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="02-线性结构2-一元多项式的乘法与加法运算-20分"><a href="#02-线性结构2-一元多项式的乘法与加法运算-20分" class="headerlink" title="02-线性结构2 一元多项式的乘法与加法运算 (20分)"></a>02-线性结构2 一元多项式的乘法与加法运算 (20分)</h4><p>设计函数分别求两个一元多项式的乘积与和。</p>
<p><strong>输入格式:</strong></p>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p><strong>输出格式:</strong></p>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>
<p><strong>输出样例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>先读入4，然后做4的循环读入这个多项式，再读入3，做3的循环读入多项式</li>
<li>并不是每组都有最后的空格，所以反过来理解，就是空格、系数、指数，第一项没有空格</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomoal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span>&#123;</span>        <span class="comment">//设置一个结构体，包括系数和次数</span></span><br><span class="line">    <span class="keyword">int</span> coef;           <span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> expon;          <span class="comment">//次数</span></span><br><span class="line">    Polynomoal next;     <span class="comment">//作为指针指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e,Polynomoal *pRear)</span>     <span class="comment">//构造新结点，插入表达式的后面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomoal P;</span><br><span class="line">    P = (Polynomoal)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;coef = c;        <span class="comment">//对新结点赋值</span></span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    (*pRear)-&gt;next = P;     <span class="comment">//rear节点指向尾</span></span><br><span class="line">    *pRear = P;         <span class="comment">//修改rear的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomoal <span class="title">ReadPoly</span><span class="params">()</span>       <span class="comment">//结点读入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">P</span>,*<span class="title">Rear</span>,*<span class="title">t</span>;</span></span><br><span class="line">    <span class="keyword">int</span> c,e,N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);                 <span class="comment">//先读入多项式的项数</span></span><br><span class="line">    P = (Polynomoal)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));  <span class="comment">//然后再构造一个节点，把数据插入节点</span></span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;           <span class="comment">//当前结果多项式的最后一项</span></span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;c,&amp;e);</span><br><span class="line">        Attach(c, e, &amp;Rear);</span><br><span class="line">    &#125;</span><br><span class="line">    Rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t = P;</span><br><span class="line">    P=P-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomoal <span class="title">Mult</span><span class="params">(Polynomoal P1,Polynomoal P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,e;</span><br><span class="line">    Polynomoal P, Rear, t1, t2, t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!P1 || !P2) &#123;           <span class="comment">//只要有一个为空，就不能进行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P = (Polynomoal)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    t1 = P1;</span><br><span class="line">    t2 = P2;</span><br><span class="line">    <span class="keyword">while</span> (t2) &#123;</span><br><span class="line">        e = t1-&gt;expon+t2-&gt;expon;</span><br><span class="line">        c = t1-&gt;coef*t2-&gt;coef;</span><br><span class="line">        Attach(c, e, &amp;Rear);</span><br><span class="line">        t2 = t2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (t1) &#123;</span><br><span class="line">        t2 = P2;</span><br><span class="line">        Rear = P;</span><br><span class="line">        <span class="keyword">while</span> (t2) &#123;</span><br><span class="line">            e = t1-&gt;expon+t2-&gt;expon;</span><br><span class="line">            c = t1-&gt;coef*t2-&gt;coef;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;next &amp;&amp; Rear-&gt;next-&gt;expon&gt;e) &#123;</span><br><span class="line">                Rear = Rear-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Rear-&gt;next&amp;&amp;Rear-&gt;next-&gt;expon == e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Rear-&gt;next-&gt;coef+c) &#123;           <span class="comment">//判别一下是不是等于0</span></span><br><span class="line">                    Rear-&gt;next-&gt;coef += c;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t = Rear-&gt;next;</span><br><span class="line">                    Rear-&gt;next = t-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = (Polynomoal)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">                t-&gt;coef = c;</span><br><span class="line">                t-&gt;expon = e;</span><br><span class="line">                t-&gt;next = Rear-&gt;next;</span><br><span class="line">                Rear-&gt;next = t;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t1=t1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Rear-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t2 = P;</span><br><span class="line">    P = P-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t2);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomoal <span class="title">Add</span><span class="params">(Polynomoal P1,Polynomoal P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    Polynomoal P, Rear, t1, t2, t;</span><br><span class="line">    t1 = P1;</span><br><span class="line">    t2 = P2;</span><br><span class="line">    P = (Polynomoal)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    Rear = P;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;expon == t2-&gt;expon) &#123;</span><br><span class="line">            c = t1-&gt;coef+t2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                Attach(c, t1-&gt;expon, &amp;Rear);</span><br><span class="line">            &#125;</span><br><span class="line">            t1=t1-&gt;next;</span><br><span class="line">            t2=t2-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;expon&gt;t2-&gt;expon)&#123;</span><br><span class="line">            Rear-&gt;next = t1;</span><br><span class="line">            Rear = t1;</span><br><span class="line">            t1=t1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Rear-&gt;next = t2;</span><br><span class="line">            Rear = t2;</span><br><span class="line">            t2=t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Rear-&gt;next = t1?t1:t2;</span><br><span class="line">    t = P;</span><br><span class="line">    P = P-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomoal P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomoal t;</span><br><span class="line">    t = P;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d "</span>,t-&gt;coef,t-&gt;expon);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,t-&gt;coef,t-&gt;expon);</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomoal P1, P2, PP, PS;</span><br><span class="line">    </span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    PS = Add(P1,P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-线性结构1-两个有序链表序列的合并-15分"><a href="#02-线性结构1-两个有序链表序列的合并-15分" class="headerlink" title="02-线性结构1 两个有序链表序列的合并 (15分)"></a>02-线性结构1 两个有序链表序列的合并 (15分)</h4><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p>
<p><strong>函数接口定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>List</code>结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure>
<p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p>
<p><strong>裁判测试程序样例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 5</span><br><span class="line">5</span><br><span class="line">2 4 6 8 10</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10 </span><br><span class="line">NULL</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>合并两个单链表，并且递增排序</li>
<li>先申请一个P，用t来存储P作为返回值</li>
<li>因为L1和L2都带有头结点，所以先用t1、t2替换指向下一结点</li>
<li>判断t1、t2是否都不为空，再判断t1是否为空，t2是否为空</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List t1,t2,P,t;</span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    t = P;</span><br><span class="line">    t1 = L1;</span><br><span class="line">    t1 = t1-&gt;Next;</span><br><span class="line">    t2 = L2;</span><br><span class="line">    t2 = t2-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span> (t1&amp;&amp;t2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;Data &lt; t2-&gt;Data)&#123;</span><br><span class="line">            P-&gt;Next = t1;</span><br><span class="line">            P = P-&gt;Next;</span><br><span class="line">            t1 = t1-&gt;Next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            P-&gt;Next = t2;</span><br><span class="line">            P = P-&gt;Next;</span><br><span class="line">            t2 = t2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*下面两个判断可以直接写为P-&gt;Next = t1?t1:t2;*/</span></span><br><span class="line">    <span class="keyword">if</span> (t1) &#123;</span><br><span class="line">        P-&gt;Next = t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t2) &#123;</span><br><span class="line">        P-&gt;Next = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-线性结构4-Pop-Sequence-25分"><a href="#02-线性结构4-Pop-Sequence-25分" class="headerlink" title="02-线性结构4 Pop Sequence (25分)"></a>02-线性结构4 Pop Sequence (25分)</h4><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>
<p><strong>Output Specification:</strong></p>
<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先理解题意，是要判断给定的出栈顺序是否可以在这个只能顺序入栈的堆栈里实现</li>
<li>例如5，6，4，3，7，2，1，首先，是判断5位的栈，先放入1，2，3，4，5，再取出5，再顺序放入6，再取出6，再取出4，3，再放入7，再取出7，2，1，满足了顺序入栈的要求，所以是YES</li>
<li>又例如1，7，6，5，4，3，2，先放入1，再取出1，再放入2，3，4，5，6，发现已经达到5个的上限，不能放7，此时也能取出，所以是NO</li>
<li>使用stack实现，发现空或栈顶不等于当前读到的数，则顺序压栈</li>
<li>发现栈长度大于1，并且栈顶元素等于读入元素，再并且读到的是true，就使当前的栈顶元素出栈</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> nt = n;    <span class="comment">//每次循环重新判断</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (nt--) &#123;</span><br><span class="line">				<span class="keyword">int</span> num;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num); <span class="comment">//读取第一个数的值</span></span><br><span class="line">				<span class="keyword">if</span> (flag) &#123;				 </span><br><span class="line">						<span class="keyword">while</span> (s.empty() || s.top() != num) &#123;</span><br><span class="line">								s.push(j++);	<span class="comment">//将j压入栈中，j加1</span></span><br><span class="line">								<span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; m) &#123;  <span class="comment">//如果栈大小超出m，说明错误</span></span><br><span class="line">            				flag = <span class="literal">false</span>;</span><br><span class="line">            				<span class="keyword">break</span>; </span><br><span class="line">          			&#125;</span><br><span class="line">              	<span class="comment">//直到判断读入的数与压入栈的栈顶的数相同则退出</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (flag &amp;&amp; s.<span class="built_in">size</span>() &gt;= <span class="number">1</span> &amp;&amp; s.top() == num)</span><br><span class="line">									s.pop(); 	<span class="comment">//栈顶元素与输入数相同时，栈顶元素1出栈</span></span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) </span><br><span class="line">      	<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">      	<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-线性结构3-Reversing-Linked-List-25分"><a href="#02-线性结构3-Reversing-Linked-List-25分" class="headerlink" title="02-线性结构3 Reversing Linked List (25分)"></a>02-线性结构3 Reversing Linked List (25分)</h4><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul>
<li>使用一个结构体数组按照题目给出的顺序先把数据全部存入</li>
<li>再使用一个数组，用来存放确定的地址</li>
<li>要给一个p=first，让第二个数组等于p，然后p等于结构体数组的a[first].next</li>
<li>再使用翻转函数</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000	<span class="comment">//题目要求最大不超过10的5次方</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;a[MAX];        <span class="comment">//构建这个结构体数组用来存放数据和下一位地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[MAX];  <span class="comment">//用来存放地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> address,ddata,nnext;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;address&gt;&gt;ddata&gt;&gt;nnext;</span><br><span class="line">        a[address].data = ddata;</span><br><span class="line">        a[address].next = nnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = first;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="number">-1</span>) &#123;      <span class="comment">//如果遇到-1，表明结束</span></span><br><span class="line">        <span class="built_in">list</span>[j++] = p;</span><br><span class="line">        p = a[p].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i+k&lt;=j) &#123;</span><br><span class="line">        reverse(&amp;<span class="built_in">list</span>[i], &amp;<span class="built_in">list</span>[i+k]); <span class="comment">//翻转函数</span></span><br><span class="line">        i=i+k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;j<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,<span class="built_in">list</span>[i],a[<span class="built_in">list</span>[i]].data,<span class="built_in">list</span>[i+<span class="number">1</span>]); <span class="comment">//%05，前面为0时补齐5位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,<span class="built_in">list</span>[i],a[<span class="built_in">list</span>[i]].data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/18/%E4%BA%8C%E5%88%B7C%E8%AF%AD%E8%A8%80/" rel="prev" title="二刷C语言">
      <i class="fa fa-chevron-left"></i> 二刷C语言
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/18/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88/" rel="next" title="鼠标点击特效">
      鼠标点击特效 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一讲-基本概念"><span class="nav-number">1.</span> <span class="nav-text">第一讲 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-什么是算法"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 什么是算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-应用实例：最大子列和问题"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 应用实例：最大子列和问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01-复杂度1-最大子列和问题-20分"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">01-复杂度1 最大子列和问题(20分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路：使用在线处理算法"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">思路：使用在线处理算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码："><span class="nav-number">1.3.0.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#01-复杂度2-Maximum-Subsequence-Sum-25分"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">01-复杂度2 Maximum Subsequence Sum(25分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路："><span class="nav-number">1.3.0.5.</span> <span class="nav-text">思路：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码：-1"><span class="nav-number">1.3.0.6.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#01-复杂度3-二分查找-20分"><span class="nav-number">1.3.0.7.</span> <span class="nav-text">01-复杂度3 二分查找(20分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路：-1"><span class="nav-number">1.3.0.8.</span> <span class="nav-text">思路：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遇到的问题："><span class="nav-number">1.3.0.9.</span> <span class="nav-text">遇到的问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码：-2"><span class="nav-number">1.3.0.10.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二讲-线性结构"><span class="nav-number">2.</span> <span class="nav-text">第二讲 线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-线性表及其实现"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 线性表及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#习题"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">习题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-堆栈"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#习题-1"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">习题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-队列及实现"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 队列及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#02-线性结构2-一元多项式的乘法与加法运算-20分"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">02-线性结构2 一元多项式的乘法与加法运算 (20分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02-线性结构1-两个有序链表序列的合并-15分"><span class="nav-number">2.3.0.4.</span> <span class="nav-text">02-线性结构1 两个有序链表序列的合并 (15分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-1"><span class="nav-number">2.3.0.5.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-1"><span class="nav-number">2.3.0.6.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02-线性结构4-Pop-Sequence-25分"><span class="nav-number">2.3.0.7.</span> <span class="nav-text">02-线性结构4 Pop Sequence (25分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-2"><span class="nav-number">2.3.0.8.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-2"><span class="nav-number">2.3.0.9.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02-线性结构3-Reversing-Linked-List-25分"><span class="nav-number">2.3.0.10.</span> <span class="nav-text">02-线性结构3 Reversing Linked List (25分)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-3"><span class="nav-number">2.3.0.11.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-3"><span class="nav-number">2.3.0.12.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang QiAn"
      src="http://image.guziyf.com/avatar">
  <p class="site-author-name" itemprop="name">Wang QiAn</p>
  <div class="site-description" itemprop="description">正视无知，消除傲慢</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/guziyf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;guziyf" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:805170066@qq.com" title="E-Mail → mailto:805170066@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang QiAn</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  

</body>
</html>
